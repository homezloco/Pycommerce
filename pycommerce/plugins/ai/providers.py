
"""
AI Providers for PyCommerce platform.
"""
import logging
import random
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any

logger = logging.getLogger(__name__)

class AIProvider(ABC):
    """Base abstract class for AI providers."""
    
    @abstractmethod
    def generate_content(self, prompt: str) -> str:
        """Generate content based on a prompt."""
        pass
    
    @abstractmethod
    def summarize_text(self, text: str) -> str:
        """Summarize a given text."""
        pass
    
    @abstractmethod
    def analyze_sentiment(self, text: str) -> Dict[str, Any]:
        """Analyze sentiment of a given text."""
        pass

class MockAIProvider(AIProvider):
    """Mock AI provider for testing and development."""
    
    def __init__(self):
        """Initialize mock provider."""
        self.sample_responses = [
            "This is a sample response from the mock AI provider. It simulates what an AI would generate in response to your prompt.",
            "The mock AI provider is useful for testing and development without incurring costs or requiring external API access.",
            "In a production environment, you would typically use an actual AI service like OpenAI's GPT models.",
            "This text was generated by the PyCommerce mock provider, not by a real AI model."
        ]
        logger.info("Mock AI provider initialized")
    
    def generate_content(self, prompt: str) -> str:
        """Generate mock content based on a prompt."""
        logger.info(f"Mock AI generating content for prompt: {prompt[:50]}...")
        
        # Return a mix of sample responses
        response_parts = []
        num_paragraphs = random.randint(2, 4)
        
        for _ in range(num_paragraphs):
            response_parts.append(random.choice(self.sample_responses))
        
        # Add a reference to the prompt to make it seem more relevant
        if prompt and len(prompt) > 10:
            prompt_topic = prompt.split(" ")[-3:]  # Get last few words
            topic_phrase = " ".join(prompt_topic)
            response_parts.append(f"Regarding '{topic_phrase}', this is just a mock response and not actual AI-generated content.")
        
        return "<p>" + "</p><p>".join(response_parts) + "</p>"
    
    def summarize_text(self, text: str) -> str:
        """Summarize a given text."""
        logger.info(f"Mock AI summarizing text: {text[:50]}...")
        return "This is a mock summary generated by the PyCommerce mock AI provider."
    
    def analyze_sentiment(self, text: str) -> Dict[str, Any]:
        """Analyze sentiment of a given text."""
        logger.info(f"Mock AI analyzing sentiment: {text[:50]}...")
        sentiments = ["positive", "negative", "neutral"]
        return {
            "sentiment": random.choice(sentiments),
            "confidence": random.uniform(0.7, 0.95),
            "note": "This is mock sentiment analysis"
        }

class OpenAIProvider(AIProvider):
    """OpenAI GPT provider."""
    
    def __init__(self, api_key: str, model: str = "gpt-3.5-turbo"):
        """Initialize OpenAI provider."""
        self.api_key = api_key
        self.model = model
        self.openai = None
        
        try:
            import openai
            self.openai = openai
            self.openai.api_key = api_key
            logger.info(f"OpenAI provider initialized with model: {model}")
        except ImportError:
            logger.error("OpenAI package not installed. Please install with: pip install openai")
            raise ImportError("OpenAI package not installed")
        except Exception as e:
            logger.error(f"Error initializing OpenAI: {str(e)}")
            raise
    
    def generate_content(self, prompt: str) -> str:
        """Generate content using OpenAI."""
        if not self.openai:
            raise RuntimeError("OpenAI not properly initialized")
        
        logger.info(f"OpenAI generating content for prompt: {prompt[:50]}...")
        
        try:
            response = self.openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": "You are a helpful assistant for an e-commerce platform."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=1000
            )
            
            content = response.choices[0].message.content
            # Convert newlines to paragraph breaks for HTML
            content = "<p>" + content.replace("\n\n", "</p><p>") + "</p>"
            return content
        except Exception as e:
            logger.error(f"Error with OpenAI API: {str(e)}")
            # Fall back to simple error message
            return f"<p>Error generating content with OpenAI: {str(e)}</p>"
    
    def summarize_text(self, text: str) -> str:
        """Summarize text using OpenAI."""
        if not self.openai:
            raise RuntimeError("OpenAI not properly initialized")
        
        logger.info(f"OpenAI summarizing text: {text[:50]}...")
        
        try:
            response = self.openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": "Summarize the following text concisely:"},
                    {"role": "user", "content": text}
                ],
                max_tokens=150
            )
            
            return response.choices[0].message.content
        except Exception as e:
            logger.error(f"Error with OpenAI API for summarization: {str(e)}")
            return f"Error summarizing content: {str(e)}"
    
    def analyze_sentiment(self, text: str) -> Dict[str, Any]:
        """Analyze sentiment using OpenAI."""
        if not self.openai:
            raise RuntimeError("OpenAI not properly initialized")
        
        logger.info(f"OpenAI analyzing sentiment: {text[:50]}...")
        
        try:
            response = self.openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": "Analyze the sentiment of the following text. Respond with a JSON object containing 'sentiment' (positive, negative, or neutral) and 'confidence' (a number between 0 and 1):"},
                    {"role": "user", "content": text}
                ],
                max_tokens=100
            )
            
            content = response.choices[0].message.content
            
            # Try to parse JSON
            import json
            try:
                result = json.loads(content)
                if not isinstance(result, dict):
                    raise ValueError("Response is not a dictionary")
                if "sentiment" not in result:
                    result["sentiment"] = "neutral"
                if "confidence" not in result:
                    result["confidence"] = 0.5
                return result
            except json.JSONDecodeError:
                # Fall back to basic sentiment extraction
                if "positive" in content.lower():
                    sentiment = "positive"
                elif "negative" in content.lower():
                    sentiment = "negative"
                else:
                    sentiment = "neutral"
                
                return {
                    "sentiment": sentiment,
                    "confidence": 0.7,
                    "raw_response": content
                }
        except Exception as e:
            logger.error(f"Error with OpenAI API for sentiment analysis: {str(e)}")
            return {
                "sentiment": "neutral",
                "confidence": 0,
                "error": str(e)
            }
